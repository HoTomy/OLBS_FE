import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-J43GMYXM.js";

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          throw new Error(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/koa-compose/index.js
var require_koa_compose = __commonJS({
  "node_modules/koa-compose/index.js"(exports, module) {
    "use strict";
    module.exports = compose;
    function compose(middleware) {
      if (!Array.isArray(middleware))
        throw new TypeError("Middleware stack must be an array!");
      for (const fn of middleware) {
        if (typeof fn !== "function")
          throw new TypeError("Middleware must be composed of functions!");
      }
      return function(context, next) {
        let index = -1;
        return dispatch(0);
        function dispatch(i) {
          if (i <= index)
            return Promise.reject(new Error("next() called multiple times"));
          index = i;
          let fn = middleware[i];
          if (i === middleware.length)
            fn = next;
          if (!fn)
            return Promise.resolve();
          try {
            return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
          } catch (err) {
            return Promise.reject(err);
          }
        }
      };
    }
  }
});

// node_modules/depd/lib/browser/index.js
var require_browser = __commonJS({
  "node_modules/depd/lib/browser/index.js"(exports, module) {
    "use strict";
    module.exports = depd;
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      function deprecate(message) {
      }
      deprecate._file = void 0;
      deprecate._ignored = true;
      deprecate._namespace = namespace;
      deprecate._traced = false;
      deprecate._warned = /* @__PURE__ */ Object.create(null);
      deprecate.function = wrapfunction;
      deprecate.property = wrapproperty;
      return deprecate;
    }
    function wrapfunction(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      return fn;
    }
    function wrapproperty(obj, prop, message) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
    }
  }
});

// node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS({
  "node_modules/setprototypeof/index.js"(exports, module) {
    "use strict";
    module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
  }
});

// node_modules/statuses/codes.json
var require_codes = __commonJS({
  "node_modules/statuses/codes.json"(exports, module) {
    module.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/statuses/index.js
var require_statuses = __commonJS({
  "node_modules/statuses/index.js"(exports, module) {
    "use strict";
    var codes = require_codes();
    module.exports = status;
    status.message = codes;
    status.code = createMessageToStatusCodeMap(codes);
    status.codes = createStatusCodeList(codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map = {};
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        map[message.toLowerCase()] = status2;
      });
      return map;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code) {
        return Number(code);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status.code[msg];
    }
    function getStatusMessage(code) {
      if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
        throw new Error("invalid status code: " + code);
      }
      return status.message[code];
    }
    function status(code) {
      if (typeof code === "number") {
        return getStatusMessage(code);
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        return getStatusMessage(n);
      }
      return getStatusCode(code);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/toidentifier/index.js
var require_toidentifier = __commonJS({
  "node_modules/toidentifier/index.js"(exports, module) {
    "use strict";
    module.exports = toIdentifier;
    function toIdentifier(str) {
      return str.split(" ").map(function(token) {
        return token.slice(0, 1).toUpperCase() + token.slice(1);
      }).join("").replace(/[^ _0-9a-z]/gi, "");
    }
  }
});

// node_modules/http-errors/index.js
var require_http_errors = __commonJS({
  "node_modules/http-errors/index.js"(exports, module) {
    "use strict";
    var deprecate = require_browser()("http-errors");
    var setPrototypeOf = require_setprototypeof();
    var statuses = require_statuses();
    var inherits = require_inherits_browser();
    var toIdentifier = require_toidentifier();
    module.exports = createError;
    module.exports.HttpError = createHttpErrorConstructor();
    module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
    populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var type = typeof arg;
        if (type === "object" && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type === "number" && i === 0) {
          status = arg;
        } else if (type === "string") {
          msg = arg;
        } else if (type === "object") {
          props = arg;
        } else {
          throw new TypeError("argument #" + (i + 1) + " unsupported type " + type);
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ClientError(message) {
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
      };
    }
    function createServerErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ServerError(message) {
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports2, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses.message[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          exports2[code] = CodeError;
          exports2[name] = CodeError;
        }
      });
    }
    function toClassName(name) {
      return name.substr(-5) !== "Error" ? name + "Error" : name;
    }
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          throw new Error(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/methods/index.js
var require_methods = __commonJS({
  "node_modules/methods/index.js"(exports, module) {
    "use strict";
    var http = require_http();
    module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
    function getCurrentNodeMethods() {
      return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
        return method.toLowerCase();
      });
    }
    function getBasicNodeMethods() {
      return [
        "get",
        "post",
        "put",
        "head",
        "delete",
        "options",
        "trace",
        "copy",
        "lock",
        "mkcol",
        "move",
        "purge",
        "propfind",
        "proppatch",
        "unlock",
        "report",
        "mkactivity",
        "checkout",
        "merge",
        "m-search",
        "notify",
        "subscribe",
        "unsubscribe",
        "patch",
        "search",
        "connect"
      ];
    }
  }
});

// node_modules/path-to-regexp/dist.es2015/index.js
var dist_exports = {};
__export(dist_exports, {
  compile: () => compile,
  match: () => match,
  parse: () => parse,
  pathToRegexp: () => pathToRegexp,
  regexpToFunction: () => regexpToFunction,
  tokensToFunction: () => tokensToFunction,
  tokensToRegexp: () => tokensToRegexp
});
function lexer(str) {
  var tokens = [];
  var i = 0;
  while (i < str.length) {
    var char = str[i];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i, value: str[i++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i, value: str[i++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i + 1;
      while (j < str.length) {
        var code = str.charCodeAt(j);
        if (code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code === 95) {
          name += str[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i));
      tokens.push({ type: "NAME", index: i, value: name });
      i = j;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j = i + 1;
      if (str[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j));
      }
      while (j < str.length) {
        if (str[j] === "\\") {
          pattern += str[j++] + str[j++];
          continue;
        }
        if (str[j] === ")") {
          count--;
          if (count === 0) {
            j++;
            break;
          }
        } else if (str[j] === "(") {
          count++;
          if (str[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j));
          }
        }
        pattern += str[j++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i));
      tokens.push({ type: "PATTERN", index: i, value: pattern });
      i = j;
      continue;
    }
    tokens.push({ type: "CHAR", index: i, value: str[i++] });
  }
  tokens.push({ type: "END", index: i, value: "" });
  return tokens;
}
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
  var defaultPattern = "[^".concat(escapeString(options.delimiter || "/#?"), "]+?");
  var result = [];
  var key = 0;
  var i = 0;
  var path = "";
  var tryConsume = function(type) {
    if (i < tokens.length && tokens[i].type === type)
      return tokens[i++].value;
  };
  var mustConsume = function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  };
  var consumeText = function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  };
  while (i < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || defaultPattern,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
function tokensToFunction(tokens, options) {
  if (options === void 0) {
    options = {};
  }
  var reFlags = flags(options);
  var _a = options.encode, encode = _a === void 0 ? function(x) {
    return x;
  } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
  var matches = tokens.map(function(token) {
    if (typeof token === "object") {
      return new RegExp("^(?:".concat(token.pattern, ")$"), reFlags);
    }
  });
  return function(data) {
    var path = "";
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (typeof token === "string") {
        path += token;
        continue;
      }
      var value = data ? data[token.name] : void 0;
      var optional = token.modifier === "?" || token.modifier === "*";
      var repeat = token.modifier === "*" || token.modifier === "+";
      if (Array.isArray(value)) {
        if (!repeat) {
          throw new TypeError('Expected "'.concat(token.name, '" to not repeat, but got an array'));
        }
        if (value.length === 0) {
          if (optional)
            continue;
          throw new TypeError('Expected "'.concat(token.name, '" to not be empty'));
        }
        for (var j = 0; j < value.length; j++) {
          var segment = encode(value[j], token);
          if (validate && !matches[i].test(segment)) {
            throw new TypeError('Expected all "'.concat(token.name, '" to match "').concat(token.pattern, '", but got "').concat(segment, '"'));
          }
          path += token.prefix + segment + token.suffix;
        }
        continue;
      }
      if (typeof value === "string" || typeof value === "number") {
        var segment = encode(String(value), token);
        if (validate && !matches[i].test(segment)) {
          throw new TypeError('Expected "'.concat(token.name, '" to match "').concat(token.pattern, '", but got "').concat(segment, '"'));
        }
        path += token.prefix + segment + token.suffix;
        continue;
      }
      if (optional)
        continue;
      var typeOfMessage = repeat ? "an array" : "a string";
      throw new TypeError('Expected "'.concat(token.name, '" to be ').concat(typeOfMessage));
    }
    return path;
  };
}
function match(str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys, options);
}
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.decode, decode = _a === void 0 ? function(x) {
    return x;
  } : _a;
  return function(pathname) {
    var m = re.exec(pathname);
    if (!m)
      return false;
    var path = m[0], index = m.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = function(i2) {
      if (m[i2] === void 0)
        return "continue";
      var key = keys[i2 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m[i2].split(key.prefix + key.suffix).map(function(value) {
          return decode(value, key);
        });
      } else {
        params[key.name] = decode(m[i2], key);
      }
    };
    for (var i = 1; i < m.length; i++) {
      _loop_1(i);
    }
    return { path, index, params };
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
    return x;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode(token));
    } else {
      var prefix = escapeString(encode(token.prefix));
      var suffix = escapeString(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            route += "((?:".concat(token.pattern, ")").concat(token.modifier, ")");
          } else {
            route += "(".concat(token.pattern, ")").concat(token.modifier);
          }
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}
var init_dist = __esm({
  "node_modules/path-to-regexp/dist.es2015/index.js"() {
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          throw new Error(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/koa-router/lib/layer.js
var require_layer = __commonJS({
  "node_modules/koa-router/lib/layer.js"(exports, module) {
    var { parse: parseUrl, format: formatUrl } = require_url();
    var { pathToRegexp: pathToRegexp2, compile: compile2, parse: parse2 } = (init_dist(), __toCommonJS(dist_exports));
    module.exports = Layer;
    function Layer(path, methods, middleware, opts = {}) {
      this.opts = opts;
      this.name = this.opts.name || null;
      this.methods = [];
      this.paramNames = [];
      this.stack = Array.isArray(middleware) ? middleware : [middleware];
      for (const method of methods) {
        const l = this.methods.push(method.toUpperCase());
        if (this.methods[l - 1] === "GET")
          this.methods.unshift("HEAD");
      }
      for (let i = 0; i < this.stack.length; i++) {
        const fn = this.stack[i];
        const type = typeof fn;
        if (type !== "function")
          throw new Error(
            `${methods.toString()} \`${this.opts.name || path}\`: \`middleware\` must be a function, not \`${type}\``
          );
      }
      this.path = path;
      this.regexp = pathToRegexp2(path, this.paramNames, this.opts);
    }
    Layer.prototype.match = function(path) {
      return this.regexp.test(path);
    };
    Layer.prototype.params = function(path, captures, params = {}) {
      for (let len = captures.length, i = 0; i < len; i++) {
        if (this.paramNames[i]) {
          const c = captures[i];
          if (c && c.length > 0)
            params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;
        }
      }
      return params;
    };
    Layer.prototype.captures = function(path) {
      return this.opts.ignoreCaptures ? [] : path.match(this.regexp).slice(1);
    };
    Layer.prototype.url = function(params, options) {
      let args = params;
      const url = this.path.replace(/\(\.\*\)/g, "");
      if (typeof params !== "object") {
        args = Array.prototype.slice.call(arguments);
        if (typeof args[args.length - 1] === "object") {
          options = args[args.length - 1];
          args = args.slice(0, -1);
        }
      }
      const toPath = compile2(url, { encode: encodeURIComponent, ...options });
      let replaced;
      const tokens = parse2(url);
      let replace = {};
      if (Array.isArray(args)) {
        for (let len = tokens.length, i = 0, j = 0; i < len; i++) {
          if (tokens[i].name)
            replace[tokens[i].name] = args[j++];
        }
      } else if (tokens.some((token) => token.name)) {
        replace = params;
      } else if (!options) {
        options = params;
      }
      replaced = toPath(replace);
      if (options && options.query) {
        replaced = parseUrl(replaced);
        if (typeof options.query === "string") {
          replaced.search = options.query;
        } else {
          replaced.search = void 0;
          replaced.query = options.query;
        }
        return formatUrl(replaced);
      }
      return replaced;
    };
    Layer.prototype.param = function(param, fn) {
      const { stack } = this;
      const params = this.paramNames;
      const middleware = function(ctx, next) {
        return fn.call(this, ctx.params[param], ctx, next);
      };
      middleware.param = param;
      const names = params.map(function(p) {
        return p.name;
      });
      const x = names.indexOf(param);
      if (x > -1) {
        stack.some(function(fn2, i) {
          if (!fn2.param || names.indexOf(fn2.param) > x) {
            stack.splice(i, 0, middleware);
            return true;
          }
        });
      }
      return this;
    };
    Layer.prototype.setPrefix = function(prefix) {
      if (this.path) {
        this.path = this.path !== "/" || this.opts.strict === true ? `${prefix}${this.path}` : prefix;
        this.paramNames = [];
        this.regexp = pathToRegexp2(this.path, this.paramNames, this.opts);
      }
      return this;
    };
    function safeDecodeURIComponent(text) {
      try {
        return decodeURIComponent(text);
      } catch {
        return text;
      }
    }
  }
});

// node_modules/koa-router/lib/router.js
var require_router = __commonJS({
  "node_modules/koa-router/lib/router.js"(exports, module) {
    var { debuglog } = require_util();
    var compose = require_koa_compose();
    var HttpError = require_http_errors();
    var methods = require_methods();
    var { pathToRegexp: pathToRegexp2 } = (init_dist(), __toCommonJS(dist_exports));
    var Layer = require_layer();
    var debug = debuglog("koa-router");
    module.exports = Router;
    function Router(opts = {}) {
      if (!(this instanceof Router))
        return new Router(opts);
      this.opts = opts;
      this.methods = this.opts.methods || [
        "HEAD",
        "OPTIONS",
        "GET",
        "PUT",
        "PATCH",
        "POST",
        "DELETE"
      ];
      this.exclusive = Boolean(this.opts.exclusive);
      this.params = {};
      this.stack = [];
      this.host = this.opts.host;
    }
    for (const method_ of methods) {
      let setMethodVerb2 = function(method) {
        Router.prototype[method] = function(name, path, middleware) {
          if (typeof path === "string" || path instanceof RegExp) {
            middleware = Array.prototype.slice.call(arguments, 2);
          } else {
            middleware = Array.prototype.slice.call(arguments, 1);
            path = name;
            name = null;
          }
          if (typeof path !== "string" && !(path instanceof RegExp) && (!Array.isArray(path) || path.length === 0))
            throw new Error(
              `You have to provide a path when adding a ${method} handler`
            );
          this.register(path, [method], middleware, { name });
          return this;
        };
      };
      setMethodVerb = setMethodVerb2;
      setMethodVerb2(method_);
    }
    var setMethodVerb;
    Router.prototype.del = Router.prototype["delete"];
    Router.prototype.use = function() {
      const router = this;
      const middleware = Array.prototype.slice.call(arguments);
      let path;
      if (Array.isArray(middleware[0]) && typeof middleware[0][0] === "string") {
        const arrPaths = middleware[0];
        for (const p of arrPaths) {
          router.use.apply(router, [p].concat(middleware.slice(1)));
        }
        return this;
      }
      const hasPath = typeof middleware[0] === "string";
      if (hasPath)
        path = middleware.shift();
      for (const m of middleware) {
        if (m.router) {
          const cloneRouter = Object.assign(
            Object.create(Router.prototype),
            m.router,
            {
              stack: [...m.router.stack]
            }
          );
          for (let j = 0; j < cloneRouter.stack.length; j++) {
            const nestedLayer = cloneRouter.stack[j];
            const cloneLayer = Object.assign(
              Object.create(Layer.prototype),
              nestedLayer
            );
            if (path)
              cloneLayer.setPrefix(path);
            if (router.opts.prefix)
              cloneLayer.setPrefix(router.opts.prefix);
            router.stack.push(cloneLayer);
            cloneRouter.stack[j] = cloneLayer;
          }
          if (router.params) {
            let setRouterParams2 = function(paramArr) {
              const routerParams = paramArr;
              for (const key of routerParams) {
                cloneRouter.param(key, router.params[key]);
              }
            };
            var setRouterParams = setRouterParams2;
            setRouterParams2(Object.keys(router.params));
          }
        } else {
          const keys = [];
          pathToRegexp2(router.opts.prefix || "", keys);
          const routerPrefixHasParam = router.opts.prefix && keys.length;
          router.register(path || "([^/]*)", [], m, {
            end: false,
            ignoreCaptures: !hasPath && !routerPrefixHasParam
          });
        }
      }
      return this;
    };
    Router.prototype.prefix = function(prefix) {
      prefix = prefix.replace(/\/$/, "");
      this.opts.prefix = prefix;
      for (let i = 0; i < this.stack.length; i++) {
        const route = this.stack[i];
        route.setPrefix(prefix);
      }
      return this;
    };
    Router.prototype.routes = Router.prototype.middleware = function() {
      const router = this;
      const dispatch = function dispatch2(ctx, next) {
        debug("%s %s", ctx.method, ctx.path);
        const hostMatched = router.matchHost(ctx.host);
        if (!hostMatched) {
          return next();
        }
        const path = router.opts.routerPath || ctx.routerPath || ctx.path;
        const matched = router.match(path, ctx.method);
        let layerChain;
        if (ctx.matched) {
          ctx.matched.push.apply(ctx.matched, matched.path);
        } else {
          ctx.matched = matched.path;
        }
        ctx.router = router;
        if (!matched.route)
          return next();
        const matchedLayers = matched.pathAndMethod;
        const mostSpecificLayer = matchedLayers[matchedLayers.length - 1];
        ctx._matchedRoute = mostSpecificLayer.path;
        if (mostSpecificLayer.name) {
          ctx._matchedRouteName = mostSpecificLayer.name;
        }
        layerChain = (router.exclusive ? [mostSpecificLayer] : matchedLayers).reduce(function(memo, layer) {
          memo.push(function(ctx2, next2) {
            ctx2.captures = layer.captures(path, ctx2.captures);
            ctx2.params = ctx2.request.params = layer.params(
              path,
              ctx2.captures,
              ctx2.params
            );
            ctx2.routerPath = layer.path;
            ctx2.routerName = layer.name;
            ctx2._matchedRoute = layer.path;
            if (layer.name) {
              ctx2._matchedRouteName = layer.name;
            }
            return next2();
          });
          return memo.concat(layer.stack);
        }, []);
        return compose(layerChain)(ctx, next);
      };
      dispatch.router = this;
      return dispatch;
    };
    Router.prototype.allowedMethods = function(options = {}) {
      const implemented = this.methods;
      return function allowedMethods(ctx, next) {
        return next().then(function() {
          const allowed = {};
          if (!ctx.status || ctx.status === 404) {
            for (let i = 0; i < ctx.matched.length; i++) {
              const route = ctx.matched[i];
              for (let j = 0; j < route.methods.length; j++) {
                const method = route.methods[j];
                allowed[method] = method;
              }
            }
            const allowedArr = Object.keys(allowed);
            if (!~implemented.indexOf(ctx.method)) {
              if (options.throw) {
                const notImplementedThrowable = typeof options.notImplemented === "function" ? options.notImplemented() : new HttpError.NotImplemented();
                throw notImplementedThrowable;
              } else {
                ctx.status = 501;
                ctx.set("Allow", allowedArr.join(", "));
              }
            } else if (allowedArr.length > 0) {
              if (ctx.method === "OPTIONS") {
                ctx.status = 200;
                ctx.body = "";
                ctx.set("Allow", allowedArr.join(", "));
              } else if (!allowed[ctx.method]) {
                if (options.throw) {
                  const notAllowedThrowable = typeof options.methodNotAllowed === "function" ? options.methodNotAllowed() : new HttpError.MethodNotAllowed();
                  throw notAllowedThrowable;
                } else {
                  ctx.status = 405;
                  ctx.set("Allow", allowedArr.join(", "));
                }
              }
            }
          }
        });
      };
    };
    Router.prototype.all = function(name, path, middleware) {
      if (typeof path === "string") {
        middleware = Array.prototype.slice.call(arguments, 2);
      } else {
        middleware = Array.prototype.slice.call(arguments, 1);
        path = name;
        name = null;
      }
      if (typeof path !== "string" && !(path instanceof RegExp) && (!Array.isArray(path) || path.length === 0))
        throw new Error("You have to provide a path when adding an all handler");
      this.register(path, methods, middleware, { name });
      return this;
    };
    Router.prototype.redirect = function(source, destination, code) {
      if (typeof source === "symbol" || source[0] !== "/") {
        source = this.url(source);
        if (source instanceof Error)
          throw source;
      }
      if (typeof destination === "symbol" || destination[0] !== "/" && !destination.includes("://")) {
        destination = this.url(destination);
        if (destination instanceof Error)
          throw destination;
      }
      return this.all(source, (ctx) => {
        ctx.redirect(destination);
        ctx.status = code || 301;
      });
    };
    Router.prototype.register = function(path, methods2, middleware, opts = {}) {
      const router = this;
      const { stack } = this;
      if (Array.isArray(path)) {
        for (const curPath of path) {
          router.register.call(router, curPath, methods2, middleware, opts);
        }
        return this;
      }
      const route = new Layer(path, methods2, middleware, {
        end: opts.end === false ? opts.end : true,
        name: opts.name,
        sensitive: opts.sensitive || this.opts.sensitive || false,
        strict: opts.strict || this.opts.strict || false,
        prefix: opts.prefix || this.opts.prefix || "",
        ignoreCaptures: opts.ignoreCaptures
      });
      if (this.opts.prefix) {
        route.setPrefix(this.opts.prefix);
      }
      for (let i = 0; i < Object.keys(this.params).length; i++) {
        const param = Object.keys(this.params)[i];
        route.param(param, this.params[param]);
      }
      stack.push(route);
      debug("defined route %s %s", route.methods, route.path);
      return route;
    };
    Router.prototype.route = function(name) {
      const routes = this.stack;
      for (let len = routes.length, i = 0; i < len; i++) {
        if (routes[i].name && routes[i].name === name)
          return routes[i];
      }
      return false;
    };
    Router.prototype.url = function(name, params) {
      const route = this.route(name);
      if (route) {
        const args = Array.prototype.slice.call(arguments, 1);
        return route.url.apply(route, args);
      }
      return new Error(`No route found for name: ${String(name)}`);
    };
    Router.prototype.match = function(path, method) {
      const layers = this.stack;
      let layer;
      const matched = {
        path: [],
        pathAndMethod: [],
        route: false
      };
      for (let len = layers.length, i = 0; i < len; i++) {
        layer = layers[i];
        debug("test %s %s", layer.path, layer.regexp);
        if (layer.match(path)) {
          matched.path.push(layer);
          if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) {
            matched.pathAndMethod.push(layer);
            if (layer.methods.length > 0)
              matched.route = true;
          }
        }
      }
      return matched;
    };
    Router.prototype.matchHost = function(input) {
      const { host } = this;
      if (!host) {
        return true;
      }
      if (!input) {
        return false;
      }
      if (typeof host === "string") {
        return input === host;
      }
      if (typeof host === "object" && host instanceof RegExp) {
        return host.test(input);
      }
    };
    Router.prototype.param = function(param, middleware) {
      this.params[param] = middleware;
      for (let i = 0; i < this.stack.length; i++) {
        const route = this.stack[i];
        route.param(param, middleware);
      }
      return this;
    };
    Router.url = function(path) {
      const args = Array.prototype.slice.call(arguments, 1);
      return Layer.prototype.url.apply({ path }, args);
    };
  }
});

// dep:koa-router
var koa_router_default = require_router();
export {
  koa_router_default as default
};
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
//# sourceMappingURL=koa-router.js.map
